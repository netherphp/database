<?php

use Nether\Database;
use Nether\Database\Verse;

require('vendor/autoload.php');

class App
extends Nether\Console\Client {

	protected function
	OnReady():
	void {

		if(class_exists('Nether\\Atlantis\\Engine'))
		$Atlantis = new Nether\Atlantis\Engine(getcwd());

		return;
	}

	#[Nether\Console\Meta\Command('sql-create')]
	#[Nether\Console\Meta\Info('Generate the SQL to CREATE this table from the Table Class Annotations. If no database is specified it will only print the SQL to console.')]
	#[Nether\Console\Meta\Arg('fqcn', 'The full namespace and class path as your application knows the class.')]
	#[Nether\Console\Meta\Value('--db', 'Alias of the DB config to connect and execute this query on.')]
	#[Nether\Console\Meta\Toggle('--drop', 'Prepend a DROP TABLE to the query.')]
	#[Nether\Console\Meta\Toggle('-y', 'Auto confirm prompts.')]
	#[Nether\Console\Meta\Error(1, 'no class specified')]
	#[Nether\Console\Meta\Error(2, 'class not found')]
	#[Nether\Console\Meta\Error(3, 'query failed')]
	#[Nether\Console\Meta\Error(4, 'database connect failed')]
	#[Nether\Console\Meta\Error(5, 'execution cancelled')]
	public function
	HandleSqlCreate():
	int {
	/*//
	@date 2021-08-19
	read the class attributes and generate the sql required to create this
	table in the database server.
	//*/

		$Class = $this->GetInput(1);
		$DBAlias = $this->GetOption('db') ?? 'Default';
		$AutoYes = $this->GetOption('y') ?? FALSE;
		$AutoDropTable = $this->GetOption('drop') ?? FALSE;

		$SQL = NULL;
		$PreSQL = NULL;
		$FKSQL1 = NULL;
		$FKSQL2 = NULL;

		// handle the basics of making sure we have a class to inspect.

		if(!$Class)
		$this->Quit(1);

		$Class = static::TranslateClassName($Class);

		if(!class_exists($Class))
		$this->Quit(2);

		// generate create table.

		try {
			$SQL = $this->NewVerseCreate($DBAlias, $Class);
		}

		catch(Throwable $Err) {
			$this->PrintLn($Err->GetMessage());
			$this->Quit(4);
		}

		// generate drop table.

		if($AutoDropTable) {
			$PreSQL = match(TRUE) {
				$SQL->HasDatabase()
				=> $this->NewVerseDropTable($DBAlias, $Class),

				default
				=> Nether\Database\Verse::FromMetaDropTable($Class)
			};

			$FKSQL1 = 'SET FOREIGN_KEY_CHECKS=0;';
			$FKSQL2 = 'SET FOREIGN_KEY_CHECKS=1;';
		}

		////////

		// show the queries we intend to run.

		$this->PrintVerse([ $PreSQL, $SQL ]);

		// if we have no database however there is nothing to do.

		if(!$SQL->HasDatabase())
		return 0;

		// execute the queries on the current database.

		if($FKSQL1)
		$SQL->GetDatabase()->Query($FKSQL1);

		$Result = $this->ConfirmAndExecuteVerse(
			[ $PreSQL, $SQL ],
			$AutoYes
		);

		if($FKSQL2)
		$SQL->GetDatabase()->Query($FKSQL2);

		if($Result === FALSE)
		$this->Quit(3);

		return 0;
	}

	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////

	protected function
	NewVerseCreate(string $DBAlias, string $Class):
	Verse {

		$DBM = new Nether\Database\Manager;
		$DBC = $DBM->Get($DBAlias);

		$Verse = $DBC->NewClassVerse($Class, Verse::ModeCreate);
		$Verse->SetPretty(TRUE);

		return $Verse;
	}

	protected function
	NewVerseDropTable(string $DBAlias, string $Class):
	Verse {

		$DBM = new Nether\Database\Manager;
		$DBC = $DBM->Get($DBAlias);

		$Verse = $DBC->NewClassVerse($Class, Verse::ModeDropTable);
		$Verse->SetPretty(TRUE);

		return $Verse;
	}

	protected function
	PrintVerse(Verse|array $Queries):
	void {
	/*//
	@date 2022-02-20
	//*/

		$Query = NULL;

		////////

		if($Queries instanceof Verse)
		$Queries = [ $Queries ];

		////////

		$this->PrintLn('-- SQL BEGIN', '');

		foreach($Queries as $Query) {
			if(!$Query)
			continue;

			echo $Query->GetSQL(), ";", PHP_EOL, PHP_EOL;
		}

		$this->PrintLn('-- SQL END');

		return;
	}

	protected function
	ConfirmAndExecuteVerse(Verse|array $Queries, bool $Force=FALSE):
	?bool {
	/*//
	@date 2022-02-20
	//*/

		$Confirm = TRUE;
		$Database = NULL;

		////////

		if($Queries instanceof Verse)
		$Queries = [ $Queries ];

		if(!count($Queries))
		return FALSE;

		foreach($Queries as $SQL)
		if($SQL instanceof Verse)
		if($SQL->HasDatabase())
		$Database = $SQL->GetDatabase();

		if(!$Database)
		return FALSE;

		////////

		if(!$Force) {
			$this->PrintLn('');
			$Confirm = $this->PromptEquals(
				"Execute on {$Database->Database}?",
				'(y/n):',
				'y'
			);
		}

		if(!$Confirm)
		return NULL;

		////////

		foreach($Queries as $SQL) {
			if(!$SQL)
			continue;

			$Result = $SQL->Query();

			if(!$Result->IsOK()) {
				$this->PrintLn("> {$Result->GetError()}");
				return FALSE;
			}
		}

		$this->PrintLn(sprintf(
			'> OK (%d %s)',
			$Database->GetQueryCount(),
			($Database->GetQueryCount() === 1 ? 'query' : 'queries')
		));

		return TRUE;
	}

	static public function
	TranslateClassName(string $Input):
	string {
	/*//
	@date 2021-08-19
	i want to support a few different syntaxes for inputting class names
	since php went with backslashes as namespaceoperators. i said it then,
	and im saying it now. choosing backslashes to avoid extra work rather
	than make it actually be good was fukken stupid.
	//*/

		// Some.Class.Name

		if(str_contains($Input,'.'))
		return str_replace('.','\\',$Input);

		// Some-Class-Name

		if(str_contains($Input,'-'))
		return str_replace('-','\\',$Input);

		return $Input;
	}

};

(new App)->Run();
