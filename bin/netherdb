<?php

use Nether\Database;
use Nether\Database\Verse;

require('vendor/autoload.php');

class App
extends Nether\Console\Client {

	#[Nether\Console\Meta\Command('sql-create')]
	#[Nether\Console\Meta\Info('Generate the SQL to CREATE this table from the Table Class Annotations. If no database is specified it will only print the SQL to console.')]
	#[Nether\Console\Meta\Arg('fqcn', 'The full namespace and class path as your application knows the class.')]
	#[Nether\Console\Meta\Value('--db', 'Alias of the DB config to connect and execute this query on.')]
	#[Nether\Console\Meta\Toggle('--drop', 'Prepend a DROP TABLE to the query.')]
	#[Nether\Console\Meta\Toggle('-y', 'Auto confirm prompts.')]
	#[Nether\Console\Meta\Error(1, 'no class specified')]
	#[Nether\Console\Meta\Error(2, 'class not found')]
	#[Nether\Console\Meta\Error(3, 'query failed')]
	#[Nether\Console\Meta\Error(4, 'database connect failed')]
	#[Nether\Console\Meta\Error(5, 'execution cancelled')]
	public function
	HandleSqlCreate():
	int {
	/*//
	@date 2021-08-19
	read the class attributes and generate the sql required to create this
	table in the database server.
	//*/

		$Class = $this->GetInput(1);
		$DBConfig = $this->GetOption('conf') ?? NULL;
		$DBAlias = $this->GetOption('db') ?? NULL;
		$AutoYes = $this->GetOption('y') ?? FALSE;
		$AutoDropTable = $this->GetOption('drop') ?? FALSE;
		$SQL = NULL;
		$PreSQL = NULL;

		////////

		if($DBConfig && !$DBAlias)
		$DBAlias = 'Default';

		if(!$Class)
		$this->Quit(1);

		$Class = static::TranslateClassName($Class);

		if(!class_exists($Class))
		$this->Quit(2);

		////////

		try {
			$SQL = $this->NewVerseCreate(
				$DBConfig,
				$DBAlias,
				$Class
			);
		}

		catch(Throwable $Err) {
			$this->PrintLn($Err->GetMessage());
			$this->Quit(4);
		}

		if($AutoDropTable) {
			if($SQL->HasDatabase())
			$PreSQL = $SQL->GetDatabase()->NewVerseDropTable($Class);

			else
			$PreSQL = Nether\Database\Verse::FromMetaDropTable($Class);
		}

		$this->PrintVerse([
			$PreSQL,
			$SQL
		]);

		if(!$SQL->HasDatabase())
		return 0;

		$Result = $this->ConfirmAndExecuteVerse(
			[ $PreSQL, $SQL ],
			$AutoYes
		);

		if($Result === FALSE)
		$this->Quit(3);

		return 0;
	}

	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////

	#[Nether\Console\Meta\Command('config-new')]
	#[Nether\Console\Meta\Info('Generate a new config JSON at location.')]
	#[Nether\Console\Meta\Arg('filename', 'The location to install new config.')]
	#[Nether\Console\Meta\Toggle('--force', 'Force overwrite of existing file.')]
	#[Nether\Console\Meta\Error(1, 'unable to locate config template')]
	#[Nether\Console\Meta\Error(2, 'output file already exists (--force to overwrite)')]
	public function
	HandleConfigNew():
	int {

		$Outfile = $this->GetInput(1);
		$Force = $this->GetOption('Force');
		$Path = sprintf(
			'%s/templates/config.json.txt',
			dirname(__FILE__, 2)
		);

		////////

		if(!file_exists($Path))
		$this->Quit(1);

		if(file_exists($Outfile) && !$Force)
		$this->Quit(2);

		////////

		$this->PrintLn(sprintf(
			'Config Template: %s => %s',
			basename($Path),
			$Outfile
		));

		copy($Path, $Outfile);
		return 0;
	}

	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////

	protected function
	NewVerseCreate(?string $DBConfig, ?string $DBAlias, string $Class):
	Verse {

		if(!$DBConfig || !$DBAlias)
		return (
			Nether\Database\Verse::FromMetaCreate($Class)
			->SetPretty(TRUE)
		);

		$this->PrintLn("Connecting to {$DBAlias}...", '');
		Nether\Database\ConnectionConfig::LoadFromJSON($DBConfig);

		return (
			Nether\Database::Get($DBAlias)
			->NewVerseCreate($Class)
			->SetPretty(TRUE)
		);
	}

	protected function
	PrintVerse(Verse|array $Queries):
	void {
	/*//
	@date 2022-02-20
	//*/

		$Query = NULL;

		////////

		if($Queries instanceof Verse)
		$Queries = [ $Queries ];

		////////

		$this->PrintLn('-- SQL BEGIN', '');

		foreach($Queries as $Query) {
			if(!$Query)
			continue;

			echo $Query->GetSQL(), ";", PHP_EOL, PHP_EOL;
		}

		$this->PrintLn('-- SQL END');

		return;
	}

	protected function
	ConfirmAndExecuteVerse(Verse|array $Queries, bool $Force=FALSE):
	?bool {
	/*//
	@date 2022-02-20
	//*/

		$Confirm = TRUE;
		$Database = NULL;

		////////

		if($Queries instanceof Verse)
		$Queries = [ $Queries ];

		if(!count($Queries))
		return FALSE;

		foreach($Queries as $SQL)
		if($SQL instanceof Verse)
		if($SQL->HasDatabase())
		$Database = $SQL->GetDatabase();

		if(!$Database)
		return FALSE;

		////////

		if(!$Force) {
			$this->PrintLn('');
			$Confirm = $this->PromptEquals(
				"Execute on {$Database->GetAlias()}?",
				'(y/n):',
				'y'
			);
		}

		if(!$Confirm)
		return NULL;

		////////

		foreach($Queries as $SQL) {
			if(!$SQL)
			continue;

			$Result = $SQL->Query();

			if(!$Result->IsOK()) {
				$this->PrintLn("> {$Result->GetError()}");
				return FALSE;
			}
		}

		$this->PrintLn(sprintf(
			'> OK (%d %s)',
			Nether\Database::$QueryCount,
			(Nether\Database::$QueryCount === 1 ? 'query' : 'queries')
		));

		return TRUE;
	}

	static public function
	TranslateClassName(string $Input):
	string {
	/*//
	@date 2021-08-19
	i want to support a few different syntaxes for inputting class names
	since php went with backslashes as namespaceoperators. i said it then,
	and im saying it now. choosing backslashes to avoid extra work rather
	than make it actually be good was fukken stupid.
	//*/

		// Some.Class.Name

		if(str_contains($Input,'.'))
		return str_replace('.','\\',$Input);

		// Some-Class-Name

		if(str_contains($Input,'-'))
		return str_replace('-','\\',$Input);

		return $Input;
	}

};

(new App)->Run();
